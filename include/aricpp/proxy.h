/*******************************************************************************
 * ARICPP - ARI interface for C++
 * Copyright (C) 2017-2021 Daniele Pallastrelli
 *
 * This file is part of aricpp.
 * For more information, see http://github.com/daniele77/aricpp
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef ARICPP_PROXY_H_
#define ARICPP_PROXY_H_

#include <memory>
#include <string>
#include "client.h"
#include "errors.h"
#include "jsontree.h"
#include "method.h"

namespace aricpp
{


template<typename T>
class ProxyImpl
{
public:
    using ErrorHandler = std::function<void(Error, const std::string&)>;
    using AfterHandler = std::function<void(T)>;

    void After(AfterHandler f)
    {
        if (done)
        {
            f(resultValue);
            return;
        }

        if (afterHandler) // sequence of std::function
        {
            auto g = afterHandler;
            afterHandler = [g, f](T t)
            {
                g(t);
                f(t);
            };
        }
        else
            afterHandler = f;
    }

    void OnError(ErrorHandler f)
    {
        if (error)
        {
            f(errorCode, errorMsg);
            return;
        }

        if (errorHandler) // sequence of std::function
        {
            auto g = errorHandler;
            errorHandler = [g, f](Error e, const std::string& msg)
            {
                g(e, msg);
                f(e, msg);
            };
        }
        else
            errorHandler = f;
    }

    void OnResponse(const boost::system::error_code& e, int state, const std::string& reason, const std::string& /* respBody */, const T& result)
    {
        if (e)
            SetError(Error::network, e.message());
        else
        {
            if (state / 100 == 2)
                Completed(result);
            else
                SetError(Error::unknown, reason);
        }
    }


private:

    void SetError(Error e, const std::string& msg)
    {
        error = true;
        errorCode = e;
        errorMsg = msg;

        if (errorHandler)
            errorHandler(e, msg);
    }

    void Completed(const T& result)
    {
        done = true;
        resultValue = result;

        if (afterHandler)
            afterHandler(result);
    }

    ErrorHandler errorHandler;
    AfterHandler afterHandler;
    bool done = false;
    T resultValue = {};
    bool error = false;
    Error errorCode;
    std::string errorMsg;
};

///////////

template<>
class ProxyImpl<std::string>
{
public:
public:
    using ErrorHandler = std::function<void(Error, const std::string&)>;
    using AfterHandler = std::function<void(const std::string&)>;

    void After(const AfterHandler& f)
    {
        if (done)
        {
            f(resultValue);
            return;
        }
 
        if (afterHandler) // sequence of std::function
        {
            auto g = afterHandler;
            afterHandler = [g, f](std::string variable)
            {
                g(variable);
                f(variable);
            };
        }
        else
            afterHandler = f;
    }

    void OnError(const ErrorHandler& f)
    {
        if (error)
        {
            f(errorCode, errorMsg);
            return;
        }

        if (errorHandler) // sequence of std::function
        {
            auto g = errorHandler;
            errorHandler = [g, f](Error e, const std::string& msg)
            {
                g(e, msg);
                f(e, msg);
            };
        }
        else
            errorHandler = f;
    }

    void OnResponse(const boost::system::error_code& e, int state, const std::string& reason, const std::string& respBody, const std::string& /*result*/)
    {
        if (e)
            SetError(Error::network, e.message());
        else
        {
            if (state / 100 == 2)
            {
                try
                {
                    Completed(respBody);
                }
                catch (const std::exception& ex)
                {
                    SetError(Error::unknown, ex.what());
                }
            }
            else
                SetError(Error::unknown, reason);
        }
    }

private:

    void SetError(Error e, const std::string& msg)
    {
        error = true;
        errorCode = e;
        errorMsg = msg;

        if (errorHandler) errorHandler(e, msg);
    }

    void Completed(const std::string& body)
    {
        auto json = FromJson(body);
        const std::string result = Get<std::string>(json, {"value"});
        resultValue = result;
        done = true;

        if (afterHandler)
            afterHandler(result);
    }

    ErrorHandler errorHandler;
    AfterHandler afterHandler;
    bool done = false;
    std::string resultValue = {};
    bool error = false;
    Error errorCode;
    std::string errorMsg;
};

///////////

template<>
class ProxyImpl<void>
{
public:
    using ErrorHandler = std::function<void(Error, const std::string&)>;
    using AfterHandler = std::function<void(void)>;

    void After(const AfterHandler& f)
    {
        if (done)
        {
            f();
            return;
        }

        if (afterHandler) // sequence of std::function
        {
            auto g = afterHandler;
            afterHandler = [g, f]()
            {
                g();
                f();
            };
        }
        else
            afterHandler = f;
    }

    void OnError(const ErrorHandler& f)
    {
        if (error)
        {
            f(errorCode, errorMsg);
            return;
        }

        if (errorHandler) // sequence of std::function
        {
            auto g = errorHandler;
            errorHandler = [g, f](Error e, const std::string& msg)
            {
                g(e, msg);
                f(e, msg);
            };
        }
        else
            errorHandler = f;
    }

    void OnResponse(const boost::system::error_code& e, int state, const std::string& reason)
    {
        if (e)
            SetError(Error::network, e.message());
        else
        {
            if (state / 100 == 2)
                Completed();
            else
                SetError(Error::unknown, reason);
        }
    }

private:

    void SetError(Error e, const std::string& msg)
    {
        error = true;
        errorCode = e;
        errorMsg = msg;

        if (errorHandler) errorHandler(e, msg);
    }
    void Completed()
    {
        if (afterHandler) afterHandler();
    }

    ErrorHandler errorHandler;
    AfterHandler afterHandler;
    bool done = false;
    bool error = false;
    Error errorCode;
    std::string errorMsg;
};

///////////

class Proxy
{
private:
    using Impl = ProxyImpl<void>;
public:
    using AfterHandler = Impl::AfterHandler;
    using ErrorHandler = Impl::ErrorHandler;

    static Proxy CreateEmpty()
    {
        Proxy p;
        return p;
    }
    static Proxy Command(Method method, const std::string& request, Client* client, const std::string& body = {})
    {
        Proxy proxy;
        client->RawCmd(
            method,
            request,
            [proxy](auto e, int state, auto reason, auto)
            {
                proxy.impl->OnResponse(e, state, reason);
            },
            body);
        return proxy;
    }
    Proxy& After(AfterHandler f)
    {
        impl->After(std::move(f));
        return *this;
    }
    Proxy& OnError(ErrorHandler f)
    {
        impl->OnError(std::move(f));
        return *this;
    }

private:
    Proxy() : impl(std::make_shared<Impl>()) {}
    std::shared_ptr<Impl> impl;
};


template<typename T>
class ProxyPar
{
private:
    using Impl = ProxyImpl<T>;
public:
    using AfterHandler = typename Impl::AfterHandler;
    using ErrorHandler = typename Impl::ErrorHandler;

    static ProxyPar<T> CreateEmpty()
    {
        ProxyPar<T> p;
        return p;
    }

    static ProxyPar<T>
    Command(Method method, std::string request, Client* client, const T& result = {}, std::string body = {})
    {
        ProxyPar<T> proxy;
        client->RawCmd(
            method,
            std::move(request),
            [proxy, result](auto e, int state, auto reason, auto respBody)
            {
                proxy.impl->OnResponse(e, state, reason, respBody, result);
            },
            std::move(body));
        return proxy;
    }

    ProxyPar& After(AfterHandler f)
    {
        impl->After(std::move(f));
        return *this;
    }

    ProxyPar& OnError(ErrorHandler f)
    {
        impl->OnError(std::move(f));
        return *this;
    }

private:
    ProxyPar() : impl(std::make_shared<Impl>()) {}
    std::shared_ptr<Impl> impl;
};


} // namespace aricpp

#endif
